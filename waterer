#!/usr/bin/env python3

from gpiozero import DistanceSensor, OutputDevice
from gpiozero.pins.pigpio import PiGPIOFactory
from datetime import datetime
from subprocess import Popen, PIPE, STDOUT

import time
import yaml
import sys

factory = PiGPIOFactory(host="localhost")

def load_config():
    with open("config.yml", "r") as file:
        return(yaml.safe_load(file))

config = load_config()
reservoir_config = config["reservoir"]
planter_config = config["planter"]
pump_config = config["pump"]
log_config = config["log"]

reservoir = DistanceSensor(trigger=reservoir_config["trigger"], echo=reservoir_config["echo"], pin_factory=factory)
planter = DistanceSensor(trigger=planter_config["trigger"], echo=planter_config["echo"], pin_factory=factory)
pump = OutputDevice(pump_config["switch"], active_high=True, initial_value=False, pin_factory=factory)

def reservoir_level():
    return round(reservoir.distance * 100, 1)

def reservoir_volume(level):
    dv = (reservoir_config["max_volume"] - reservoir_config["min_volume"])
    dl = (reservoir_config["max_level"] - reservoir_config["min_level"])
    return((level - reservoir_config["min_level"]) * dv / dl + reservoir_config["min_volume"])

def planter_level():
    return round(planter.distance * 100, 1)

def reservoir_empty(reservoir_lvl):
    return reservoir_lvl > reservoir_config["min_level"]

def reservoir_full(reservoir_lvl):
    return reservoir_lvl < reservoir_config["max_level"]

def planter_empty(planter_lvl):
    return planter_lvl > planter_config["min_level"]

def planter_full(planter_lvl):
    return planter_lvl < planter_config["max_level"]

def planter_low(planter_lvl):
    return planter_lvl > planter_config["low_level"]

def log_filling_event(reason, start_time, reservoir_start, reservoir_end):
    end_time = datetime.utcnow()
    line = "{},{},{},{},{},{},{}\n".format(
        start_time.strftime("%F %T.%f"),
        end_time.strftime("%F %T.%f"),
        reservoir_start,
        reservoir_end,
        reservoir_volume(reservoir_start),
        reservoir_volume(reservoir_end),
        reason
    )
    with open(log_config["fill-events"], "a") as f:
        f.write(line)

def log_levels(reservoir_lvl, planter_lvl):
    line = "{},{},{},{}\n".format(
        datetime.utcnow().strftime("%F %T.%f"),
        planter_lvl,
        reservoir_lvl,
        reservoir_volume(reservoir_lvl)
    )
    with open(log_config["levels"], "a") as f:
        f.write(line)

def send_sms(message):
    try:
        proc = Popen(["./send-sms"], stdin=PIPE, stdout=PIPE, stderr=STDOUT)
        output = proc.communicate(input=message.encode())[0]
        if proc.returncode != 0:
            print(f"Error posting SMS:\n#{output.decode().strip()}", file=sys.stderr)
        return output.decode().strip()
    except FileNotFoundError:
        print("Failed to post SMS", file=sys.stderr)
        return None

def report_filling_event(reservoir_start, reservoir_end):
    message = "Xmas tree topped up with {}qt. {}qt remaining in reservoir.".format(
        round(reservoir_volume(reservoir_start) - reservoir_volume(reservoir_end), 1),
        round(reservoir_volume(reservoir_end), 1)
    )
    return send_sms(message)

def water():
    state = "idle"
    fill_start_time = None
    reservoir_start = None
    delay = 30 * 60
    try:
        print("Starting...")
        send_sms("Xmas tree waterer started...")
        while True:
            reservoir_lvl = reservoir_level()
            planter_lvl = planter_level()
            if state == "idle":
                print(f"Planter level: {planter_lvl}cm, Reservoir level: {reservoir_lvl}cm / ~{round(reservoir_volume(reservoir_lvl), 1)}qt")
                log_levels(reservoir_lvl, planter_lvl)

            if state != "empty" and reservoir_empty(reservoir_lvl):
                if state == "filling":
                    log_filling_event("reservoir empty", fill_start_time, reservoir_start, reservoir_lvl)
                    report_filling_event(reservoir_start, reservoir_lvl)
                state = "empty"
                print(f"Reservoir empty ({reservoir_lvl}cm, ~{round(reservoir_volume(reservoir_lvl), 1)}qt)")
                send_sms(f"Reservoir empty ({reservoir_lvl}cm, ~{round(reservoir_volume(reservoir_lvl), 1)}qt)")
                pump.off()
            elif state == "empty" and reservoir_full(reservoir_lvl):
                print("Reservoir no longer empty")
                send_sms(f"Reservoir filled")
                state = "idle"
            elif state == "idle" and planter_low(planter_lvl):
                fill_start_time = datetime.utcnow()
                reservoir_start = reservoir_level()
                state = "filling"
                print("Planter low")
                pump.on()
            elif state == "filling" and planter_full(planter_lvl):
                pump.off()
                log_filling_event("full", fill_start_time, reservoir_start, reservoir_lvl)
                report_filling_event(reservoir_start, reservoir_lvl)
                state = "idle"
                print("Planter full")
                print(f"Topped up by ~{round(reservoir_volume(reservoir_start) - reservoir_volume(reservoir_lvl), 2)}qt")

            if state == "filling":
                time.sleep(1)
            elif state == "empty":
                time.sleep(30 * 60)
            else:
                time.sleep(5 * 60)
    finally:
        pump.off()

if __name__ == "__main__":
    water()
